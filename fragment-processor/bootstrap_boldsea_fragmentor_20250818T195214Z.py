# Bootstrap to reconstruct boldsea_fragmentor package.
# Usage: python bootstrap_boldsea_fragmentor_20250818T195214Z.py
import os, pathlib

FILES = {"boldsea_fragmentor/__init__.py": "\"\"\"\nboldsea_fragmentor\n------------------\nA lightweight pipeline that splits raw texts (articles/chapters) into\nschema-typed fragments for later insertion into Boldsea as Fragment:* models.\n\nStages:\n  1) ingest: read PDF/text to raw pages\n  2) segment: make paragraph-like candidates with anchors\n  3) classify: pick schema model via heuristics (LLM-ready interface)\n  4) extract: schema-specific fields (heuristics now; pluggable LLM later)\n  5) export: JSONL with attributes/relations per Boldsea ontology\n\nThis package does not call any external LLM by default. You can plug your client\nby implementing the LLMExtractor interface in extractor.py.\n\"\"\"\n__all__ = [\"schemas\", \"reader\", \"segmenter\", \"classifier\", \"extractor\", \"exporter\"]\n", "boldsea_fragmentor/schemas.py": "from __future__ import annotations\nfrom enum import Enum\nfrom typing import Dict\n\nclass SchemaType(str, Enum):\n    # Basic\n    DEFINITION = \"Definition\"\n    COMPARISON = \"Comparison\"\n    CAUSAL_RELATION = \"Causal Relation\"\n    APPLICATION_CONTEXT = \"Application Context\"\n    EXAMPLE = \"Example\"\n    # Architectural/Technical\n    ARCHITECTURAL_COMPONENT = \"Architectural Component\"\n    TECHNICAL_PROCESS = \"Technical Process\"\n    ALGORITHM = \"Algorithm\"\n    # Conceptual\n    CONCEPTUAL_MODEL = \"Conceptual Model\"\n    PRINCIPLE = \"Principle\"\n    # Problem-oriented\n    PROBLEM_SOLUTION = \"Problem Solution\"\n    LIMITATIONS_AND_CHALLENGES = \"Limitations And Challenges\"\n    # Functional\n    FUNCTIONALITY = \"Functionality\"\n    CAPABILITIES = \"Capabilities\"\n    # Integration\n    SYSTEM_INTEGRATION = \"System Integration\"\n    COMPONENT_INTERACTION = \"Component Interaction\"\n    # Applied\n    USE_CASE = \"Use Case\"\n    CONCEPT_IMPLEMENTATION = \"Concept Implementation\"\n    CODE_SNIPPET = \"Code Snippet\"\n    ENUMERATION = \"Enumeration\"\n    TABLE_ANALYSIS = \"Table Analysis\"\n    ADVANTAGE_DISADVANTAGE = \"Advantage Disadvantage\"\n    # Fallback\n    UNKNOWN = \"Unknown\"\n\nSCHEMA_INSTRUCTIONS: Dict[str, Dict[str, str]] = {\n    SchemaType.DEFINITION.value: {\n        \"display_name\": \"Определение\",\n        \"llm_prompt_template\": \"Извлеки из определения: term (определяемый термин), includes (термины, упомянутые в определении)\",\n        \"extraction_fields\": '{\"term\": \"Range: Term\", \"includes\": \"Range: Term, Multiple: 1\"}',\n    },\n    SchemaType.COMPARISON.value: {\n        \"display_name\": \"Сравнение\",\n        \"llm_prompt_template\": \"Извлеки из сравнения: target (основной объект сравнения), comparator (с чем сравнивается), criterion (критерии сравнения), advantage (у кого преимущество по каждому критерию)\",\n        \"extraction_fields\": '{\"target\": \"Range: Term\", \"comparator\": \"Range: Term\", \"criterion\": \"Range: Term, Multiple: 1\", \"advantage\": \"SetRange: [target, comparator]\"}',\n    },\n    SchemaType.CAUSAL_RELATION.value: {\n        \"display_name\": \"Причинно-следственная связь\",\n        \"llm_prompt_template\": \"Извлеки причинно-следственные связи: cause (причины, факторы влияния), effect (следствия, результаты)\",\n        \"extraction_fields\": '{\"cause\": \"Range: Term, Multiple: 1\", \"effect\": \"Range: Term, Multiple: 1\"}',\n    },\n    SchemaType.APPLICATION_CONTEXT.value: {\n        \"display_name\": \"Контекст применения\",\n        \"llm_prompt_template\": \"Извлеки контекст применения: domain (область применения)\",\n        \"extraction_fields\": '{\"domain\": \"Range: Term, Multiple: 1\"}',\n    },\n    SchemaType.EXAMPLE.value: {\n        \"display_name\": \"Пример\",\n        \"llm_prompt_template\": \"Извлеки из примера: illustrates (что иллюстрирует), type (тип примера: code/scenario/analogy/counter-example)\",\n        \"extraction_fields\": '{\"illustrates\": \"Range: Term, Multiple: 1\", \"type\": \"DataType: EnumType\"}',\n    },\n    SchemaType.ARCHITECTURAL_COMPONENT.value: {\n        \"display_name\": \"Архитектурный компонент\",\n        \"llm_prompt_template\": \"Извлеки компонент системы: system_terms (к какой системе относится), purpose_terms (назначение), interfaces_terms (с чем взаимодействует), pattern_terms (архитектурные паттерны)\",\n        \"extraction_fields\": '{\"system_terms\": \"Range: Term, Multiple: 1\", \"purpose_terms\": \"Range: Term, Multiple: 1\", \"interfaces_terms\": \"Range: Term, Multiple: 1\", \"pattern_terms\": \"Range: Term, Multiple: 1\"}',\n    },\n    SchemaType.TECHNICAL_PROCESS.value: {\n        \"display_name\": \"Технический процесс\",\n        \"llm_prompt_template\": \"Извлеки технический процесс: input_types (типы входных данных), output_types (типы выходных данных), process_category (категория процесса), involves_components (задействованные компоненты)\",\n        \"extraction_fields\": '{\"input_types\": \"Range: Term, Multiple: 1\", \"output_types\": \"Range: Term, Multiple: 1\", \"process_category\": \"Range: Term\", \"involves_components\": \"Range: Term, Multiple: 1\"}',\n    },\n    SchemaType.ALGORITHM.value: {\n        \"display_name\": \"Алгоритм/Метод\",\n        \"llm_prompt_template\": \"Извлеки алгоритм: input_types (типы входных данных), output_types (результаты), involves_components (используемые концепты), process_category (тип алгоритма)\",\n        \"extraction_fields\": '{\"input_types\": \"Range: Term, Multiple: 1\", \"output_types\": \"Range: Term, Multiple: 1\", \"involves_components\": \"Range: Term, Multiple: 1\", \"process_category\": \"Range: Term\"}',\n    },\n    SchemaType.CONCEPTUAL_MODEL.value: {\n        \"display_name\": \"Концептуальная модель\",\n        \"llm_prompt_template\": \"Извлеки концептуальную модель: target (центральный концепт), involves_components (связанные концепты)\",\n        \"extraction_fields\": '{\"target\": \"Range: Term\", \"involves_components\": \"Range: Term, Multiple: 1\"}',\n    },\n    SchemaType.PRINCIPLE.value: {\n        \"display_name\": \"Принцип/Подход\",\n        \"llm_prompt_template\": \"Извлеки принцип: target (принцип/подход), domain (к чему применяется), comparator (с чем контрастирует), demonstrates (что обеспечивает)\",\n        \"extraction_fields\": '{\"target\": \"Range: Term\", \"domain\": \"Range: Term, Multiple: 1\", \"comparator\": \"Range: Term, Multiple: 1\", \"demonstrates\": \"Range: Term, Multiple: 1\"}',\n    },\n    SchemaType.PROBLEM_SOLUTION.value: {\n        \"display_name\": \"Проблема и решение\",\n        \"llm_prompt_template\": \"Извлеки проблему и решение: problem_domain (область проблемы), solution_components (компоненты решения)\",\n        \"extraction_fields\": '{\"problem_domain\": \"Range: Term, Multiple: 1\", \"solution_components\": \"Range: Term, Multiple: 1\"}',\n    },\n    SchemaType.LIMITATIONS_AND_CHALLENGES.value: {\n        \"display_name\": \"Ограничения и вызовы\",\n        \"llm_prompt_template\": \"Извлеки ограничения: target (к чему относится), problem_domain (тип ограничения/проблемы)\",\n        \"extraction_fields\": '{\"target\": \"Range: Term\", \"problem_domain\": \"Range: Term, Multiple: 1\"}',\n    },\n    SchemaType.FUNCTIONALITY.value: {\n        \"display_name\": \"Функциональность\",\n        \"llm_prompt_template\": \"Извлеки функциональность: system_terms (система/компонент), purpose_terms (функции), involves_components (зависимости)\",\n        \"extraction_fields\": '{\"system_terms\": \"Range: Term\", \"purpose_terms\": \"Range: Term, Multiple: 1\", \"involves_components\": \"Range: Term, Multiple: 1\"}',\n    },\n    SchemaType.CAPABILITIES.value: {\n        \"display_name\": \"Возможности\",\n        \"llm_prompt_template\": \"Извлеки возможности: target (что обладает возможностями), purpose_terms (типы возможностей), demonstrates (какие сценарии обеспечивает)\",\n        \"extraction_fields\": '{\"target\": \"Range: Term\", \"purpose_terms\": \"Range: Term, Multiple: 1\", \"demonstrates\": \"Range: Term, Multiple: 1\"}',\n    },\n    SchemaType.SYSTEM_INTEGRATION.value: {\n        \"display_name\": \"Интеграция систем\",\n        \"llm_prompt_template\": \"Извлеки интеграцию: target (основная система), comparator (интегрируемая система), interfaces_terms (точки интеграции), process_category (метод интеграции)\",\n        \"extraction_fields\": '{\"target\": \"Range: Term\", \"comparator\": \"Range: Term\", \"interfaces_terms\": \"Range: Term, Multiple: 1\", \"process_category\": \"Range: Term\"}',\n    },\n    SchemaType.COMPONENT_INTERACTION.value: {\n        \"display_name\": \"Взаимодействие компонентов\",\n        \"llm_prompt_template\": \"Извлеки взаимодействие: target (инициатор), comparator (цель взаимодействия), process_category (тип взаимодействия), involves_components (посредники)\",\n        \"extraction_fields\": '{\"target\": \"Range: Term\", \"comparator\": \"Range: Term\", \"process_category\": \"Range: Term\", \"involves_components\": \"Range: Term, Multiple: 1\"}',\n    },\n    SchemaType.USE_CASE.value: {\n        \"display_name\": \"Сценарий использования\",\n        \"llm_prompt_template\": \"Извлеки сценарий: domain (предметная область), actors (участники), demonstrates (что демонстрирует)\",\n        \"extraction_fields\": '{\"domain\": \"Range: Term\", \"actors\": \"Range: Term, Multiple: 1\", \"demonstrates\": \"Range: Term, Multiple: 1\"}',\n    },\n    SchemaType.CONCEPT_IMPLEMENTATION.value: {\n        \"display_name\": \"Реализация концепции\",\n        \"llm_prompt_template\": \"Извлеки реализацию: concept_ref (реализуемый концепт), technologies (используемые технологии), key_features (ключевые особенности)\",\n        \"extraction_fields\": '{\"concept_ref\": \"Range: Term\", \"technologies\": \"Range: Term, Multiple: 1\", \"key_features\": \"Range: Term, Multiple: 1\"}',\n    },\n    SchemaType.CODE_SNIPPET.value: {\n        \"display_name\": \"Фрагмент кода\",\n        \"llm_prompt_template\": \"Extract only if fragment contains actual code/script/grammar. Извлеки код: language (язык программирования/формат), illustrates (что демонстрирует), input_types (входные параметры), output_types (выходные значения), keywords (ключевые термины)\",\n        \"extraction_fields\": '{\"language\": \"Range: Term\", \"illustrates\": \"Range: Term, Multiple: 1\", \"input_types\": \"Range: Term, Multiple: 1\", \"output_types\": \"Range: Term, Multiple: 1\", \"keywords\": \"Range: Term, Multiple: 1\"}',\n    },\n    SchemaType.ENUMERATION.value: {\n        \"display_name\": \"Перечисление/Список\",\n        \"llm_prompt_template\": \"Extract only if fragment is a clear list/enumeration. Извлеки список: category (тип/тема списка), items (элементы списка как термины), keywords (ключевые термины)\",\n        \"extraction_fields\": '{\"category\": \"Range: Term\", \"items\": \"Range: Term, Multiple: 1\", \"keywords\": \"Range: Term, Multiple: 1\"}',\n    },\n    SchemaType.TABLE_ANALYSIS.value: {\n        \"display_name\": \"Таблица/Матрица\",\n        \"llm_prompt_template\": \"Extract only if fragment contains structured table/matrix. Извлеки таблицу: rows (строки как термины), columns (столбцы как термины), values (значения на пересечениях), keywords (ключевые термины)\",\n        \"extraction_fields\": '{\"rows\": \"Range: Term, Multiple: 1\", \"columns\": \"Range: Term, Multiple: 1\", \"values\": \"Range: Term, Multiple: 1\", \"keywords\": \"Range: Term, Multiple: 1\"}',\n    },\n    SchemaType.ADVANTAGE_DISADVANTAGE.value: {\n        \"display_name\": \"Преимущества и недостатки\",\n        \"llm_prompt_template\": \"Extract only if fragment clearly lists pros/cons. Извлеки: target (объект анализа), advantages (преимущества как термины), disadvantages (недостатки как термины), keywords (ключевые термины)\",\n        \"extraction_fields\": '{\"target\": \"Range: Term\", \"advantages\": \"Range: Term, Multiple: 1\", \"disadvantages\": \"Range: Term, Multiple: 1\", \"keywords\": \"Range: Term, Multiple: 1\"}',\n    },\n    SchemaType.UNKNOWN.value: {\n        \"display_name\": \"Неопределено\",\n        \"llm_prompt_template\": \"\",\n        \"extraction_fields\": \"{}\",\n    },\n}\n", "boldsea_fragmentor/reader.py": "from __future__ import annotations\nfrom typing import List, Tuple\nimport os\n\ndef read_text_file(path: str) -> List[Tuple[int, str]]:\n    with open(path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n        txt = f.read()\n    return [(1, txt)]\n\ndef read_pdf(path: str) -> List[Tuple[int, str]]:\n    pages: List[Tuple[int, str]] = []\n    try:\n        import PyPDF2\n        reader = PyPDF2.PdfReader(path)\n        for i, page in enumerate(reader.pages, start=1):\n            try:\n                text = page.extract_text() or \"\"\n            except Exception:\n                text = \"\"\n            pages.append((i, text))\n        return pages\n    except Exception:\n        pass\n    try:\n        from pdfminer.high_level import extract_text\n        txt = extract_text(path) or \"\"\n        return [(1, txt)]\n    except Exception:\n        pass\n    return [(1, \"\")]\n\ndef read_any(path: str) -> List[Tuple[int, str]]:\n    ext = os.path.splitext(path)[1].lower()\n    if ext in (\".txt\", \".md\", \".rst\"):\n        return read_text_file(path)\n    if ext == \".pdf\":\n        return read_pdf(path)\n    return read_text_file(path)\n", "boldsea_fragmentor/segmenter.py": "from __future__ import annotations\nfrom dataclasses import dataclass\nfrom typing import List, Tuple\nimport re\n\n@dataclass\nclass FragmentCandidate:\n    page: int\n    anchor: str\n    text: str\n\ndef normalize_text(s: str) -> str:\n    s = s.replace(\"\\u00A0\", \" \").replace(\"\\xa0\", \" \")\n    s = re.sub(r\"[ \\t]+\", \" \", s)\n    s = re.sub(r\"\\s+\\n\", \"\\n\", s)\n    s = re.sub(r\"\\n{3,}\", \"\\n\\n\", s)\n    return s.strip()\n\ndef split_into_paragraphs(page_num: int, page_text: str) -> List[FragmentCandidate]:\n    txt = normalize_text(page_text)\n    if not txt:\n        return []\n    chunks = re.split(r\"\\n\\s*\\n\", txt)\n    frags: List[FragmentCandidate] = []\n    offset = 0\n    for ch in chunks:\n        ch = ch.strip()\n        if not ch:\n            offset += 1\n            continue\n        lines = [ln.strip() for ln in ch.split(\"\\n\")]\n        if all(re.match(r\"^([\\-•\\*]|\\d+[\\)\\.]|[a-z]\\))\\s+\", ln) or len(ln) < 160 for ln in lines) and len(lines) > 1:\n            para = \" \".join(lines)\n        else:\n            para = \" \".join(lines)\n        if len(para) < 10:\n            offset += len(ch) + 2\n            continue\n        anchor = f\"{page_num}:{offset}-{offset+len(ch)}\"\n        frags.append(FragmentCandidate(page=page_num, anchor=anchor, text=para))\n        offset += len(ch) + 2\n    return frags\n\ndef segment_pages(pages: List[Tuple[int, str]]) -> List[FragmentCandidate]:\n    result: List[FragmentCandidate] = []\n    for page_num, page_text in pages:\n        result.extend(split_into_paragraphs(page_num, page_text))\n    return result\n", "boldsea_fragmentor/classifier.py": "from __future__ import annotations\nfrom dataclasses import dataclass\nfrom typing import Tuple, List\nimport re\nfrom .schemas import SchemaType\n\n@dataclass\nclass Classified:\n    schema: SchemaType\n    confidence: float\n    reasons: List[str]\n\nRX = {\n    \"definition\": re.compile(r\"\\bопределение\\b|\\bопределяется как\\b|\\bэто\\b|\\bis a\\b|\\brefers to\\b\", re.IGNORECASE),\n    \"comparison\": re.compile(r\"\\bв отличие от\\b|\\bпо сравнению\\b|\\bсравнива(ет|ются)\\b|\\bvs\\b|\\bпротив\\b\", re.IGNORECASE),\n    \"cause\": re.compile(r\"\\bприводит к\\b|\\bв результате\\b|\\bпотому что\\b|\\bобусловлен(о|а|ы)\\b|\\bdue to\\b|\\bresults? in\\b\", re.IGNORECASE),\n    \"application\": re.compile(r\"\\bприменяется\\b|\\bиспользуется в\\b|\\bобласти применени|\\bapplication context\\b\", re.IGNORECASE),\n    \"example\": re.compile(r\"\\bнапример\\b|\\bпример(ом)?\\b|\\be\\.g\\.\\b|\\bfor example\\b\", re.IGNORECASE),\n    \"arch_component\": re.compile(r\"\\bкомпонент\\b|\\bмодуль\\b|\\bдвижок\\b|\\bengine\\b|\\bконтроллер\\b\", re.IGNORECASE),\n    \"tech_process\": re.compile(r\"\\bвходн(ые|ых)\\b|\\bвыходн(ые|ых)\\b|\\bpipeline\\b|\\bпроцесс\\b\", re.IGNORECASE),\n    \"algorithm\": re.compile(r\"\\bалгоритм\\b|\\bметод\\b|\\bшаг(и)?\\b|\\bprocedure\\b\", re.IGNORECASE),\n    \"concept_model\": re.compile(r\"\\bконцептуальн(ая|ой) модель\\b|\\bмодель\\b.*\\bконцепт\\b\", re.IGNORECASE),\n    \"principle\": re.compile(r\"\\bпринцип\\b|\\bподход\\b|\\bконтрастирует\\b|\\bобеспечивает\\b\", re.IGNORECASE),\n    \"problem_solution\": re.compile(r\"\\bпроблем(а|ы)\\b|\\bрешени(е|я)\\b|\\bподход\\b\", re.IGNORECASE),\n    \"limits\": re.compile(r\"\\bограничени(е|я)\\b|\\bвызов(ы)?\\b|\\bсложност(ь|и)\\b\", re.IGNORECASE),\n    \"functionality\": re.compile(r\"\\bфункциональност(ь|и)\\b|\\bфункци(я|и)\\b\", re.IGNORECASE),\n    \"capabilities\": re.compile(r\"\\bвозможност(ь|и)\\b|\\bспособности\\b\", re.IGNORECASE),\n    \"integration\": re.compile(r\"\\bинтеграци(я|и)\\b|\\bсовместимост(ь|и)\\b|\\bAPI\\b\", re.IGNORECASE),\n    \"component_interaction\": re.compile(r\"\\bвзаимодействи(е|я)\\b|\\bобмен\\b|\\bчерез\\b\", re.IGNORECASE),\n    \"use_case\": re.compile(r\"\\bсценари(й|я)\\b|\\bакто(р|ры)\\b|\\bпользователь\\b|\\bшаг(и)?\\b\", re.IGNORECASE),\n    \"concept_impl\": re.compile(r\"\\bреализаци(я|и)\\b|\\bтехнологи(я|и)\\b|\\bфреймворк\\b|\\bframework\\b\", re.IGNORECASE),\n    \"enumeration\": re.compile(r\"(^|\\n)[\\-•\\*] +|(^|\\n)\\d+[\\)\\.] +\", re.IGNORECASE),\n    \"table\": re.compile(r\"\\|.*\\|.*\\||\\bтаблиц(а|ы)\\b\", re.IGNORECASE),\n    \"adv_disadv\": re.compile(r\"\\bпреимущест(ва|во)\\b|\\bнедостатк(и|ов)\\b|\\bплюсы\\b|\\bминусы\\b\", re.IGNORECASE),\n    \"code\": re.compile(r\"```|\\{{\\}}|\\bclass\\b|\\bdef\\b|;\\s*$|\\bpublic\\b|\\bvoid\\b|\\bfunction\\b\", re.IGNORECASE),\n}\n\ndef is_code_like(text: str) -> bool:\n    if RX[\"code\"].search(text):\n        return True\n    letters = sum(ch.isalpha() for ch in text)\n    nonspace = sum(not ch.isspace() for ch in text)\n    if nonspace > 0 and letters / nonspace < 0.5 and (\"{\" in text or \";\" in text or \"(\" in text):\n        return True\n    return False\n\ndef classify_fragment(text: str) -> Classified:\n    t = text.strip()\n    reasons: List[str] = []\n\n    if is_code_like(t):\n        return Classified(schema=SchemaType.CODE_SNIPPET, confidence=0.95, reasons=[\"code-like\"])\n\n    if RX[\"enumeration\"].search(t) and len(t) < 2000:\n        reasons.append(\"bullet/numbered list\")\n        return Classified(schema=SchemaType.ENUMERATION, confidence=0.85, reasons=reasons)\n\n    if RX[\"table\"].search(t):\n        reasons.append(\"table/matrix pattern\")\n        return Classified(schema=SchemaType.TABLE_ANALYSIS, confidence=0.8, reasons=reasons)\n\n    if RX[\"adv_disadv\"].search(t):\n        reasons.append(\"pros/cons lexemes\")\n        return Classified(schema=SchemaType.ADVANTAGE_DISADVANTAGE, confidence=0.8, reasons=reasons)\n\n    checks: List[tuple] = [\n        (SchemaType.DEFINITION, \"definition\"),\n        (SchemaType.COMPARISON, \"comparison\"),\n        (SchemaType.CAUSAL_RELATION, \"cause\"),\n        (SchemaType.APPLICATION_CONTEXT, \"application\"),\n        (SchemaType.EXAMPLE, \"example\"),\n        (SchemaType.ARCHITECTURAL_COMPONENT, \"arch_component\"),\n        (SchemaType.TECHNICAL_PROCESS, \"tech_process\"),\n        (SchemaType.ALGORITHM, \"algorithm\"),\n        (SchemaType.CONCEPTUAL_MODEL, \"concept_model\"),\n        (SchemaType.PRINCIPLE, \"principle\"),\n        (SchemaType.PROBLEM_SOLUTION, \"problem_solution\"),\n        (SchemaType.LIMITATIONS_AND_CHALLENGES, \"limits\"),\n        (SchemaType.FUNCTIONALITY, \"functionality\"),\n        (SchemaType.CAPABILITIES, \"capabilities\"),\n        (SchemaType.SYSTEM_INTEGRATION, \"integration\"),\n        (SchemaType.COMPONENT_INTERACTION, \"component_interaction\"),\n        (SchemaType.USE_CASE, \"use_case\"),\n        (SchemaType.CONCEPT_IMPLEMENTATION, \"concept_impl\"),\n    ]\n\n    top_schema = SchemaType.UNKNOWN\n    top_hits = 0\n    for schema, key in checks:\n        if RX[key].search(t):\n            reasons.append(key)\n            top_schema = schema\n            top_hits += 1\n\n    if top_schema != SchemaType.UNKNOWN:\n        conf = 0.6 + min(0.3, 0.1 * (top_hits - 1))\n        return Classified(schema=top_schema, confidence=conf, reasons=reasons)\n\n    if \":\" in t and len(t) < 300:\n        return Classified(schema=SchemaType.DEFINITION, confidence=0.5, reasons=[\"colon-short\"])\n\n    return Classified(schema=SchemaType.UNKNOWN, confidence=0.2, reasons=[\"fallback\"])\n", "boldsea_fragmentor/extractor.py": "from __future__ import annotations\nfrom dataclasses import dataclass\nfrom typing import Dict, Any\nimport re\nfrom .schemas import SchemaType\n\n@dataclass\nclass ExtractedFields:\n    fields: Dict[str, Any]\n    confidence: float\n\ndef _simple_term(s: str) -> str:\n    s = s.strip(\" .,:;«»\\\"'()[]{}\\n\\t\")\n    return re.sub(r\"\\s+\", \" \", s)\n\ndef extract_fields(schema: SchemaType, text: str) -> ExtractedFields:\n    t = text.strip()\n\n    if schema == SchemaType.DEFINITION:\n        m = re.match(r\"^([A-Za-zА-Яа-я0-9 _\\-/]+?)\\s*[—:-]\\s*(.+)$\", t)\n        if m:\n            term = _simple_term(m.group(1))\n            includes = [w for w in re.findall(r\"[A-Za-zА-Яа-я][A-Za-zА-Яа-я\\- ]{2,}\", m.group(2)) if len(w.split())<=4][:6]\n            return ExtractedFields({\"term\": term, \"includes\": includes}, 0.7)\n        m = re.search(r\"^([A-Za-z][\\w \\-]{1,50})\\s+is\\s+a[n]?\\s+([A-Za-z][\\w \\-]{1,80})\", t, re.IGNORECASE)\n        if m:\n            term = _simple_term(m.group(1))\n            inc = [_simple_term(m.group(2))]\n            return ExtractedFields({\"term\": term, \"includes\": inc}, 0.6)\n        return ExtractedFields({}, 0.3)\n\n    if schema == SchemaType.COMPARISON:\n        m = re.match(r\"^([\\wА-Яа-я \\-]+?)\\s+(?:vs|в отличие от)\\s+([\\wА-Яа-я \\-]+)\", t, re.IGNORECASE)\n        if m:\n            return ExtractedFields({\"target\": _simple_term(m.group(1)), \"comparator\": _simple_term(m.group(2))}, 0.6)\n        return ExtractedFields({}, 0.3)\n\n    if schema == SchemaType.CAUSAL_RELATION:\n        m = re.search(r\"(.+?)\\s+приводит к\\s+(.+)\", t, re.IGNORECASE)\n        if m:\n            return ExtractedFields({\"cause\": [_simple_term(m.group(1))], \"effect\": [_simple_term(m.group(2))]}, 0.6)\n        return ExtractedFields({}, 0.3)\n\n    if schema == SchemaType.APPLICATION_CONTEXT:\n        m = re.search(r\"используется в\\s+([A-Za-zА-Яа-я ,\\-]+)\", t, re.IGNORECASE)\n        if m:\n            dom = [d.strip() for d in re.split(r\",| и \", m.group(1)) if d.strip()]\n            return ExtractedFields({\"domain\": dom[:5]}, 0.6)\n        return ExtractedFields({}, 0.3)\n\n    if schema == SchemaType.EXAMPLE:\n        m = re.search(r\"например[:,]?\\s+(.+)$\", t, re.IGNORECASE)\n        if m:\n            return ExtractedFields({\"illustrates\": [_simple_term(m.group(1)[:120])]}, 0.5)\n        return ExtractedFields({}, 0.3)\n\n    if schema in (SchemaType.ARCHITECTURAL_COMPONENT, SchemaType.TECHNICAL_PROCESS, SchemaType.ALGORITHM,\n                  SchemaType.CONCEPTUAL_MODEL, SchemaType.PRINCIPLE, SchemaType.PROBLEM_SOLUTION,\n                  SchemaType.LIMITATIONS_AND_CHALLENGES, SchemaType.FUNCTIONALITY, SchemaType.CAPABILITIES,\n                  SchemaType.SYSTEM_INTEGRATION, SchemaType.COMPONENT_INTERACTION, SchemaType.USE_CASE,\n                  SchemaType.CONCEPT_IMPLEMENTATION, SchemaType.ENUMERATION, SchemaType.TABLE_ANALYSIS,\n                  SchemaType.ADVANTAGE_DISADVANTAGE):\n        return ExtractedFields({}, 0.3)\n\n    if schema == SchemaType.CODE_SNIPPET:\n        return ExtractedFields({}, 0.8)\n\n    return ExtractedFields({}, 0.2)\n", "boldsea_fragmentor/exporter.py": "from __future__ import annotations\nfrom dataclasses import dataclass\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime\nimport uuid\n\n@dataclass\nclass FragmentEnvelope:\n    model_identifier: str\n    document_ref: str\n    text: str\n    fragment_anchor: str\n    category: Optional[List[str]]\n    relations: Dict[str, Any]\n    attributes: Dict[str, Any]\n    confidence: float\n    event_id: str\n    actor: str\n    created_at: str\n\ndef to_jsonl(envelopes: List[FragmentEnvelope]) -> str:\n    import json\n    return \"\\n\".join(_to_event_payload(env) for env in envelopes)\n\ndef _to_event_payload(env: FragmentEnvelope) -> str:\n    import json\n    event = {\n        \"SetModel\": f\"Fragment: Model: {env.model_identifier}\",\n        \"Document\": env.document_ref,\n        \"Attributes\": {\n            \"text\": env.text,\n            \"fragment_anchor\": env.fragment_anchor,\n            \"confidence\": env.confidence,\n        },\n        \"Relations\": env.relations,\n        \"Extra\": {\n            \"category\": env.category or [],\n            \"attributes\": env.attributes,\n        },\n        \"EventMeta\": {\n            \"event_id\": env.event_id,\n            \"actor\": env.actor,\n            \"created_at\": env.created_at,\n        },\n    }\n    return json.dumps(event, ensure_ascii=False)\n\ndef build_envelopes(predictions, document_ref: str, actor: str = \"system\") -> List[FragmentEnvelope]:\n    now = datetime.utcnow().isoformat() + \"Z\"\n    envs: List[FragmentEnvelope] = []\n    for p in predictions:\n        envs.append(FragmentEnvelope(\n            model_identifier=p[\"schema\"],\n            document_ref=document_ref,\n            text=p[\"text\"],\n            fragment_anchor=p[\"anchor\"],\n            category=p.get(\"category\"),\n            relations=p.get(\"relations\", {}),\n            attributes=p.get(\"attributes\", {}),\n            confidence=p.get(\"confidence\", 0.0),\n            event_id=str(uuid.uuid4()),\n            actor=actor,\n            created_at=now\n        ))\n    return envs\n", "boldsea_fragmentor/demo_run.py": "from __future__ import annotations\nfrom typing import List, Dict, Any\nfrom .reader import read_any\nfrom .segmenter import segment_pages, FragmentCandidate\nfrom .classifier import classify_fragment\nfrom .extractor import extract_fields\nfrom .schemas import SchemaType\nfrom .exporter import build_envelopes, to_jsonl\n\ndef run_demo(path: str, max_pages: int = 3, max_frags: int = 60) -> Dict[str, Any]:\n    pages = read_any(path)\n    if max_pages and len(pages) > max_pages:\n        pages = pages[:max_pages]\n    cands: List[FragmentCandidate] = segment_pages(pages)\n    results = []\n    for c in cands[:max_frags]:\n        cls = classify_fragment(c.text)\n        ext = extract_fields(cls.schema, c.text)\n        results.append({\n            \"page\": c.page,\n            \"anchor\": c.anchor,\n            \"text\": c.text[:5000],\n            \"schema\": cls.schema.value,\n            \"confidence\": round((cls.confidence + ext.confidence) / 2, 3),\n            \"attributes\": {},\n            \"relations\": ext.fields,\n        })\n    return {\n        \"fragments\": results,\n        \"pages_read\": len(pages),\n    }\n\ndef export_jsonl(results: Dict[str, Any], document_ref: str, out_path: str) -> str:\n    envs = build_envelopes(results[\"fragments\"], document_ref=document_ref)\n    jsl = to_jsonl(envs)\n    with open(out_path, \"w\", encoding=\"utf-8\") as f:\n        f.write(jsl)\n    return out_path\n", "boldsea_fragmentor/README.md": "# boldsea_fragmentor\n\nPipeline to split raw text/PDF into Boldsea schema-typed fragments:\n**Definition, Comparison, Causal Relation, Application Context, Example,\nArchitectural Component, Technical Process, Algorithm, Conceptual Model,\nPrinciple, Problem Solution, Limitations And Challenges, Functionality,\nCapabilities, System Integration, Component Interaction, Use Case,\nConcept Implementation, Code Snippet, Enumeration, Table Analysis,\nAdvantage Disadvantage**.\n\nProduces JSONL payloads ready to POST to your Boldsea API.\n\n## Quickstart\n```python\nfrom boldsea_fragmentor.demo_run import run_demo, export_jsonl\nres = run_demo(\"your.pdf\", max_pages=3, max_frags=60)\nexport_jsonl(res, document_ref=\"Document:Individual:your_doc\", out_path=\"fragments.jsonl\")\n```\n"}

def main():
    for rel, content in FILES.items():
        p = pathlib.Path(rel)
        p.parent.mkdir(parents=True, exist_ok=True)
        with open(p, "w", encoding="utf-8") as fh:
            fh.write(content)
    with open("requirements.txt", "w", encoding="utf-8") as req:
        req.write("PyPDF2>=3.0.0\npdfminer.six>=20221105\npandas>=1.5.0\n")
    print("Package written. Next: pip install -r requirements.txt")

if __name__ == "__main__":
    main()
